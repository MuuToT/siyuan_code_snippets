import json
import logging
import os
import time
from itertools import chain

siyuan_doc_path = "b:/note/Siyuan"  # 填写实际的思源文本路径,
siyuan_doc_path_test = "./output/"  # 测试路径
conf_path = "data/snippets/conf.json"

siyuan_conf_path = os.path.join(siyuan_doc_path, conf_path)
test_conf_path = os.path.join(siyuan_doc_path_test, conf_path)
# 这里增加屏蔽的代码片段文件
# 也可以将不要的代码片段文件添加到 just_collection 中 也不会生成
ban_snippets = set()

do_time = time.strftime("%Y%m%d%H%M%S", time.localtime())
snippet_id = 0


def get_id():
    """
    Generate a unique snippet ID based on the script run timestamp and an incremented counter.

    This function uses a global counter, `snippet_id`, which is incremented each time
    the function is called. The ID consists of the script run date and time in the format
    'YYYYMMDDHHMMSS', followed by a hyphen and a zero-padded seven-digit counter.

    Returns:
        str: A unique snippet ID in the format 'YYYYMMDDHHMMSS-XXXXXXX'.
    """
    global snippet_id
    snippet_id += 1
    return f"{do_time}-{str(snippet_id).zfill(7)}"


class OutputFlag:
    TEST = 1 << 1
    SIYUAN = 1 << 2


class BaseSnippets:
    _type = ""

    def __init__(self, name, enable, file_path):
        self.id = get_id()
        self.name = name
        self.enable = enable
        self.content = self.load_from_file(file_path)

    def load_from_file(self, file_path):
        with open(file_path, "r", encoding="utf-8") as f:
            return "".join(f.readlines())

    def data_json(self):
        return {
            "id": self.id,
            "name": self.name,
            "type": self._type,
            "enabled": self.enable,
            "content": self.content,
        }


class CSSSnippets(BaseSnippets):
    _type = "css"


class JSSnippets(BaseSnippets):
    _type = "js"


class SnippetConfig:
    def __init__(self):
        self.js = []
        self.css = []
        self.Init()

    def Init(self):
        self.load_css()
        self.load_js()

    def load_js(self):
        for snippet_name, file_path in self.traverse_directory_os(
                path="./js",
                extensions=['.js']
        ):
            self.js.append(JSSnippets(snippet_name, snippet_name not in ban_snippets, file_path))

    def load_css(self):
        for snippet_name, file_path in self.traverse_directory_os(
                path="./css",
                extensions=['.css']
        ):
            self.css.append(CSSSnippets(snippet_name, snippet_name not in ban_snippets, file_path))

    def output_json(self, output_target):
        """
        Outputs the collected snippets as JSON data to the specified target path(s).

        The method takes a single argument, `output_target`, which is a bit field of
        `OutputFlag` values. The method will output the collected snippets to the
        corresponding target path(s) if the respective flag is set.

        The output is a JSON array containing the JSON data of each snippet,
        generated by calling `data_json()` on each snippet object.

        Args:
            output_target (int): A bit field of `OutputFlag` values, indicating the target
                path(s) to output the snippets to.
        """
        _all = []
        for i in chain(self.css, self.js):
            _all.append(i.data_json())

        def output(path):
            self.check_and_create_not_exist_save_path(path)
            with open(path, "w", encoding="utf-8") as f:
                json.dump(_all, f, indent=2, ensure_ascii=False)

        if output_target & OutputFlag.SIYUAN:
            output(siyuan_conf_path)
        if output_target & OutputFlag.TEST:
            output(test_conf_path)

    @staticmethod
    def check_and_create_not_exist_save_path(path):
        """
        Checks if a path exists and creates the directory if it doesn't exist.

        The path can be either a directory or a file. If the path is a directory,
        it will be created if it doesn't exist. If the path is a file, the parent
        directory will be created if it doesn't exist.
        Args:
            path (str): The path to check and create.
        """
        if os.path.exists(path):
            return
        if os.path.isdir(path):
            os.makedirs(path, exist_ok=True)
        else:
            os.makedirs("/".join(path.split("/")[:-1]), exist_ok=True)

    @staticmethod
    def traverse_directory_os(path: str, ignore_hidden: bool = True, extensions: list = None):
        """
        Traverse a directory and yield snippet names and file paths.

        This method walks through the specified directory, optionally ignoring hidden
        directories and files. It yields the snippet name and the full file path for each
        file found that matches the specified extensions.

        Args:
            path (str): The root directory to start the traversal from.
            ignore_hidden (bool, optional): If set to True, hidden directories and files
                are ignored. Defaults to True.
            extensions (list, optional): A list of file extensions to filter by. If provided,
                only files with these extensions will be yielded. Defaults to None.

        Yields:
            tuple: A tuple containing the snippet name and the file path for each matching file.
        """
        for root, dirs, files in os.walk(path):
            # 可选：排除隐藏子目录（如 .git等）
            if ignore_hidden:
                dirs[:] = [d for d in dirs if not d.startswith('.')]

            for filename in files:
                if ignore_hidden and filename.startswith('.'):
                    continue
                if extensions and os.path.splitext(filename)[1].lower() not in extensions:
                    continue
                name = root[len(path) + 1:].replace("\\", "-")
                snippet_name = f"{name}-{os.path.splitext(filename)[0]}"
                file_path = os.path.join(root, filename)
                yield snippet_name, file_path


if __name__ == '__main__':
    flag = 0
    flag |= OutputFlag.SIYUAN  # 输出思源
    flag |= OutputFlag.TEST  # 输出测试
    SnippetConfig().output_json(flag)
    print(f"finish {flag}")
